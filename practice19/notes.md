* 01-exit-_exit.c: 
	* exit(0) -- функция из libc: скидывает буферы etc, а потом syscall exit
	* _ exit_(0) -- просто syscall exit
	* Если сделать printf("Hello \n"); до буфер сброситься сразу, до fork

* 02-fork-pipe.c: 
	* int arr[2]; pipe(arr); -- два дескриптора: read и write концы pipe 
	* массив arr (который хранит дескрипторы концов pipe) копируется при fork
	* т.е. на два file descriptor object (два конца pipe), которые описывает pipe внутри kernel, есть 4 ссылки (4 дескрипторы: два на read end, два на write end)

	* Для каналов, именованных каналов и сокетов системный вызов read работает следующим образом:

		1. Если в буфере канала есть данные (хотя бы один байт), системный вызов read скопирует в буфер пользователя (то есть считает) данные из буфера канала частично или полностью. Системный вызов read завершится немедленно, а процесс не будет заблокирован. Размер считанных данных определяется минимальным значением из количества данных в буфере канала в ядре и размером буфера, переданного в системный вызов read.

		1. Если буфер канала в ядре ОС пуст, и записывающая сторона канала закрыта, системный вызов read возвращает 0, сигнализируя таким образом о достижении конца файла. Данных из этого канала больше не будет, и считывающий процесс должен обработать эту ситуацию. Это может быть закрытие файлового дескриптора и завершение работы программы.

		1. Если буфер канала в ядре ОС пуст, но записывающая сторона канала не закрыта, то есть в каком-то процессе есть открытый файловый дескриптор для записи в этот канал, то процесс, выполняющий чтение, будет заблокирован ядром ОС до наступления условий 1) или 2). Несколько процессов могут быть заблокированы на чтении из одного канала, и тогда когда наступит условие 1) или 2) разбужены будут все процессы. Возможно, правда, что часть из них снова будет переведена в режим сна из-за отсутствия данных в буфере канала в ядре ОС, так как другие проснувшиеся процессы его опустошили.

	* Нужно закрыть лишние ссылки на file descriptor object, иначе read заблокируется. read выходит, когда либо есть данные на чтение в file descriptor object, либо file descriptor object закрыт (не осталось ссылок == закрыты все файловые дескрипторы)
		```
			if (fork()) { // parent пишет
				...
				// закрыть <<лишний>> дескриптор на читающий конец
		        close(arr[0]);
		        ...
		    } else { // child читает
		    	...
		    	// закрыть <<лишний>> дескриптор на пищущий конец
		    	close(arr[1]); 
		    	...
		    }    
		```


* 03-env.sh, 03-env.c
	* Окружение процесса -- это набор поименованных строковых значений (`PATH=/usr/bin`). Некоторые переменные окружения имеют специальный смысл для функций стандартной библиотеки или для утилит командной строки. 

* 04-exec.c
	* Основной системный вызов для замещения тела процесса - execve, определенный следующим образом:
	 `int execve(const char *pathname, char *const argv[], char *const envp[]);`

		* Аргумент pathname — это абсолютный или относительный путь к исполняемому файлу для запуска. argv — массив аргументов командной строки для запускаемой программы, envp — окружение запускаемой программы.

		* Аргументы командной строки передаются в параметре argv. Это должен быть адрес начала массива указателей на строки, которые будут переданы в запускаемую программу. Последним обрабатываемым элементом массива указателей является указатель NULL.

		* Окружение в запускаемую программу передаётся с помощью параметра envp. Это должен быть адрес начала массива указателей на строки, которые будут переданы в запускаемую программу как окружение. Последним обрабатываемым элементом массива указателей является указатель NULL.

	* Окружение процесса (`char *const envp[]`) -- это набор поименованных строковых значений (`PATH=/usr/bin`). Некоторые переменные окружения имеют специальный смысл для функций стандартной библиотеки или для утилит командной строки. При запуске программы на выполнение с помощью execve есть несколько вариантов.

		1. Передать в запускаемую программу копию текущих переменных окружения. Для этого нужно использовать значение глобальной переменной environ. Однако, по какой-то причине, эта переменная не объявляется в заголовочных файлах стандартной библиотеки, поэтому нужно объявить эту переменную явно в начале программы -- `extern char **environ;`. Затем в качестве аргумента envp передается значение environ.

		1. Передать в запускаемую программу модифицированное текущее окружение. Для этого сначала с помощью функций стандартной библиотеки setenv или putenv модифицируется окружение, затем в качестве параметра envp передается значение переменной environ, как показано выше.

		1. Передать пустое окружение. В случае пустого окружения некоторые функции стандартной библиотеки, которые, возможно, используются запускаемой программой, могут работать некорректно. Поэтому передавать пустое окружение, пожалуй, не стоит. Но если хочется это сделать, передавайте NULL в качестве параметра envp.

		1. Передать в запускаемую программу полностью сформированное новое окружения. Для этого нужно создать массив указателей на строки и передать его в envp.

	* Виды exec
		```
		int execl(const char *pathname, const char *arg, ... /* (char  *) NULL */);
		int execlp(const char *file, const char *arg, ... /* (char  *) NULL */);
		int execle(const char *pathname, const char *arg, ... /*, (char *) NULL, char *const envp[] */);

		int execv(const char *pathname, char *const argv[]);
		int execvp(const char *file, char *const argv[]);
		int execvpe(const char *file, char *const argv[], char *const envp[]);
		```
		* Имена функций построены по одному шаблону: после имени `exec` идёт суффикс, содержащий буквы, уточняющие типы и количество передаваемых параметров. Они расшифровываются следующим образом:

			* Если в суффиксе имени присутствует буква `l` (например, `execl`), то аргументы командной строки для запускаемой
			программы передаются непосредственно в аргументах этой функции. Концом передаваемых аргументов для запускаемой программы
			является аргумент `NULL`, переданный в функцию. 

			* Если в суффиксе имени присутствует буква `v` (например, `execv`),
			то аргументы командной строки передаются в массиве указателей на строки, адрес которого передается в параметре `argv`.

			* Если в суффиксе имени присутствует буква `p` (например, `execlp`), то в качестве первого аргумента данная функция может принимать
			имя программы `file`. Имя программы --- это строка, не содержащая символ `'/'`. Если передано имя программы, то выполняется
			поиск программы с таким именем в списке каталогов, перечисленных в переменной окружения `PATH`. Если в качестве первого аргумента
			передана строка, содержащая символ `'/'`, то такая строка рассматривается как абсолютный или относительный путь к файлу,
			и переменная окружения `PATH` использоваться не будет. Если в суффиксе имени функции буква `p` отсутствует (например, `execve`),
			то в качестве первого аргумента принимается абсолютный или относительный путь к запускаемому файлу.

			* Если в суффиксе имени присутствует буква `e` (например, `execve`), то данная функция принимает указатель `envp` на массив
			переменных окружения, который должен быть передан запускающей программе. Если в суффиксе буква `e` отсутствует (например, `execlp`),
			то параметр `envp` у функции отсутствует, и в запускаемую программу передается копия текущего окружения процесса,
			полученная из глобальной переменной `environ`.


		* Например, 
		```
		    execlp("ls", "ls", "-l", NULL);
		```
		в качестве имени программы передана строка `ls`. Будет выполнен поиск программы `ls` в каталогах, перечисленных
		в переменной окружения `PATH`. Скорее всего программа будет найдена по пути `/bin/ls`, и в итоге в системный вызов
		`execve` в качестве пути к исполняемому файлу будет передан путь `/bin/ls`. Аргументы командной строки
		будут собраны в массив `argv` из аргументов функции `execlp`, и в итоге в программу `/bin/ls`
		будет передан массив строк `{ "ls", "-l", NULL }`. Обратите внимание, что `argv[0]` был сохранен
		в том виде, в котором он был передан в функцию `execlp` (второй параметр вызова функции `execlp`).

		* В случае
		```c
		    execl("ls", "ls", "-l", NULL);
		```
		переменная `PATH` использоваться не будет, путь `ls` будет рассматриваться как относительный путь, и если
		в текущем каталоге процесса нет исполняемого файла с именем `ls`, этот вызов завершится с ошибкой.
* 05-bash.c
	* Идиома fork-exec
		```

		id_t pid = fork();
	    if (pid < 0) {
	        // обработать ошибку нехватки ресурсов для создания нового процесса
	    } else if (!pid) {
	        // процесс-сын
	        // настроить параметры процесса-сына: стандартные потоки и пр.
	        execve(path, argv, environ); // загрузить исполняемый файл
	        // если выполняется код здесь, значит execve завершился с ошибкой
	        // возможно, сообщить об ошибке запуска исполняемого файла
	        _exit(1); // предпочтительно использовать `_exit`
	    } else {
	        // процесс-отец
	        // возможны разные ситуации синхронного/асинхронного исполнения
	    }
		```
	* команды (`&&`, `|`, `||`, `<`, `>`) обрабатывются bash
		* `&&` и `||` запуск программ последовательно по некоторой логике
		* `|` запуск программ параллельно, между ними pipe
		* `<`, `>` перенаправление ввода-вывода
	* программы передаются в execv

* 06-dup-fork-1.c: это обработка `<` и `>`
	* Если у запускаемой программы необходимо выполнить перенаправление стандартных потоков, используются системные вызовы семейства dup: dup, dup2 или dup3. Для перенаправления стандартного потока ввода нужно подменить файловый дескриптор 0, для перенаправления стандартного потока вывода — файловый дескриптор 1, и для перенаправления стандартного потока ошибок — файловый дескриптор 2.

	* https://ru.manpages.org/dup2/2
	
	* ` ./program.elf < file_in > file_out 2>> file_err`


* 07-dup-fork-2.c: это обработка `|`
	* `ls -l | wc -l`
