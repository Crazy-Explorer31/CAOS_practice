[copy from](https://github.com/blackav/hse-caos-2020/tree/master/12-files2#%D1%82%D0%B8%D0%BF%D1%8B-%D1%84%D0%B0%D0%B9%D0%BB%D0%BE%D0%B2)

# Файлы и каталоги

## Функции stat, fstat и lstat

```c
#include <sys/stat.h>

int stat(const char *restrict pathname, struct stat *restrict buf);
int fstat(int filedes, struct stat *buf);
int lstat(const char *restrict pathname, struct stat *restrict buf);
```
Функция stat возвращает структуру с информацией о файле, указанном в аргументе pathname. Функция fstat возвращает информацию об открытом файле, который определяется дескриптором filedes. 
Функция lstat похожа на функцию stat, но когда ей передается имя символической ссылки, она возвращает сведения о самой символической ссылке, а не о файле, на который она ссылается.
Второй аргумент, buf, является указателем на структуру, которую функция будет заполнять информацией. Определение структуры может отличаться для разных реализаций, но основная ее часть выглядит следующим образом:

```c
struct stat {
    mode_t st_mode; /* тип файла и режим (права доступа) */
    ino_t st_ino; /* номер индексного узла */
    dev_t st_dev; /* номер устройства (файловой системы) */
    dev_t st_rdev; /* номер устройства для специальных файлов */
    nlink_t st_nlink; /* количество ссылок */
    uid_t st_uid; /* идентификатор пользователя владельца */
    gid_t st_gid; /* идентификатор группы владельца */
    off_t st_size; /* размер в байтах, для обычных файлов */
    time_t st_atime; /* время последнего обращения к файлу */
    time_t st_mtime; /* время последнего изменения файла */
    time_t st_ctime; /* время последнего изменения флагов состояния файла */
    blksize_t st_blksize; /* оптимальный размер блока ввода вывода */
    blkcnt_t st_blocks; /* количество занятых дисковых блоков */
};
```
## Типы файлов

1. Обычный файл – наиболее распространенный тип файлов, который хранит данные в том или ином виде. Ядро UNIX не делает различий между
текстовыми и двоичными файлами. Любая интерпретация содержимого файла полностью возлагается на прикладную программу, обрабатываю 
щую файл.
2. Файл каталога. Файлы этого типа содержат имена других файлов и ссылки на информацию о них. Любой процесс, обладающий правом на чтение
каталога, может проверить его содержимое, но только ядро обладает правом на запись в файл каталога. Чтобы внести изменения в каталог, про 
цессы должны пользоваться функциями, обсуждаемыми в данной главе.
3. Специальный файл блочного устройства. Этот тип файлов обеспечивает буферизованный ввод вывод для таких устройств, как дисковые устрой 
ства с фиксированным размером блока.
4. Специальный файл символьного устройства. Этот тип файлов обеспечивает небуферизованный ввод вывод для устройств с переменным размером
блока. Все устройства в системе являются либо специальными файлами блочных устройств, либо специальными файлами символьных устройств.
5. FIFO, или именованный канал. Этот тип файлов используется для организации обмена информацией между процессами. 
6. Сокет. Этот тип файлов используется для организации обмена информацией между процессами через сетевые соединения. Сокеты можно применять и для обмена информацией между процессами на одной и той же ма 
шине. 
7. Символическая ссылка. Файлы этого типа представляют собой ссылки на другие файлы.

Тип файла хранится в поле st_mode структуры stat. Определить тип файла можно с помощью макроопределений, приведенных ниже 
(Макросы для определения типа файла из  ```<sys/stat.h>```)

 * S_ISREG(st_mode) Обычный файл
 * S_ISDIR(st_mode) Каталог
 * S_ISCHR(st_mode) Специальный файл символьного устройства
 * S_ISBLK(st_mode) Специальный файл блочного устройства
 * S_ISFIFO(st_mode) Канал (именованный или неименованный)
 * S_ISLNK(st_mode) Символическая ссылка
 * S_ISSOCK(st_mode) Сокет

## Системный вызов access

```c
#include <unistd.h>

int access(const char *pathname, int mode);
```

Проверяет, какие операции с файлом по данному пути процесс может выполнить. Симлинки разыменовываются. Что можно проверить (флаги в mode, можно комбинировать через побитовое или):

* F_OK - просто факт существования
* R_OK - файл можно читать
* W_OK - в файл можно писать
* X_OK - файл можно исполнить

В случае успеха (всё, что спрашивалось, можно) вызов возвращает 0. В противном случае (в том числе, в случае ошибки) вызов возвращает -1 и выставляет errno в соответствии с причиной отказа.

## Работа с каталогами.

Создание каталогов производится с помощью функции mkdir, а удаление – с помощью функции rmdir.

```c
#include <sys/stat.h>

int mkdir(const char *pathname, mode_t mode); /* Возвращает 0 в случае успеха, –1 в случае ошибки*/
```

```c
#include <unistd.h>

int rmdir(const char *pathname); /* Возвращает 0 в случае успеха, –1 в случае ошибки */
```

```c
#include <dirent.h>

DIR *opendir(const char *pathname); //Возвращает указатель в случае успеха или NULL в случае ошибки.
struct dirent *readdir(DIR *dp); // Возвращает указатель в случае успеха, 
                                 // NULL в случае достижения конца каталога или ошибки.
void rewinddir(DIR *dp); // Обнуляет текущую позицию в директории. Вызов всегда успешен.
int closedir(DIR *dp); // Парный вызов для opendir. Возвращает 0 в случае успеха или –1 в случае ошибки.
long telldir(DIR *dp); // Возвращает значение текущей позиции в каталоге, ассоциированном с dp, 
                       // или -1 в случае ошибки.
void seekdir(DIR *dp, long loc); // Устанавливает текущую позицию в директории. Вызов всегда успешен.
```

Функции telldir и seekdir не являются частью стандарта POSIX.1. Это расширения XSI стандарта Single UNIX Specification – таким образом, предполагается, что они должны быть реализованы во всех версиях UNIX, следующих этой спецификации.

Структура dirent определена в файле <dirent.h> и зависит от конкретной реализации. Однако в любой версии UNIX эта структура содержит как минимум следующие два поля:

```c
struct dirent {
    ino_t d_ino; /* номер индексного узла */
    char d_name[NAME_MAX + 1]; /* строка имени файла, завершающаяся нулевым символом */
}
```


## Функции chdir, fchdir и getcwd

Для каждого процесса определен текущий рабочий каталог. Относительно этого каталога вычисляются все относительные пути (то есть пути, которые не начинаются с символа слэша). Когда пользователь входит в систему, текущим рабочим каталогом обычно становится каталог, указанный в шестом поле записи из файла /etc/passwd, – домашний каталог пользователя. Текущий рабочий каталог – это атрибут процесса, домашний каталог – атрибут пользователя. Процесс может изменить текущий рабочий каталог с помощью функции chdirили fchdir.

```c
#include <unistd.h>

int chdir(const char *pathname);
int fchdir(int filedes); 
/* Возвращают 0 в случае успеха, –1 в случае ошибки */
```

Пример использования функции chdir

```c
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    if (chdir("/tmp") < 0) {
        fprintf(stderr, "ошибка вызова функции chdir: %s\n", strerror(errno));
        exit(1);
    }
    printf("каталог /tmp стал текущим рабочим каталогом\n");
    exit(0);
}
```

Поскольку ядро хранит сведения о текущем рабочем каталоге, должен быть способ получить его текущее значение. К сожалению, ядро хранит не полный путь к каталогу, а некоторую иную информацию, такую как указатель
на виртуальный узел (v-node) каталога. Чтобы определить абсолютный путь к текущему рабочему каталогу, нужна функция, которая будет перемещаться вверх по дереву каталогов, начиная с текущего («точка») и далее через специальные каталоги «точка - точка»,пока не достигнет корневого каталога. В каждом из промежуточных каталогов функция будет читать записи из файла каталога, пока не найдет название, которое соответствует индексному узлу предыдущего каталога. Повторяя эту процедуру до тех пор, пока небудет достигнут корневой каталог, мы в результате получим абсолютный путь к текущему рабочему каталогу. К счастью, такая функция уже существует.

```c
#include <unistd.h>

char *getcwd(char *buf, size_t size);
/* Возвращает указатель на buf в случае успеха, NULL в случае ошибки */
```

Пример использования функции getcwd

```c
#include <stdio.h>
#include <errno.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

int main(void) {
    char *ptr;
    size_t size = PATH_MAX + 1;

    if (chdir("/usr/spool/uucppublic") < 0) {
        fprintf(stderr, "ошибка вызова функции chdir: %s\n", strerror(errno));
        exit(1);
    }

    if (!(ptr = malloc(size))) {
        fprintf(stderr, "ошибка выделения памяти: %s\n", strerror(errno));
        fflush(NULL);
        abort();
    }

    if (getcwd(ptr, size) == NULL) {
        fprintf(stderr, "ошибка вызова функции getcwd: %s\n", strerror(errno));
        exit(1);
    }

    printf("cwd = %s\n", ptr);
    exit(0);
}
```

