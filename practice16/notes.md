
```
Все это я надергал из разных мест ;)
```

# Оглавление
- [Практика](#практика)
- [Bash](#bash)
- [Scripts](#scripts)


# Практика

 * нужен раздел Bash:  <https://overthewire.org/wargames/bandit/>
 * нужен раздел Scripts: `sample-task/run.sh`


# Bash

## Запуск командной строки

Доступ к командной строке осуществляется:
 * Запуском программы-терминала
 * Локальным входом в систему (при отсутствии графического рабочего окружения)
 * Удаленным входом по SSH

## Команды и аргументы

Многие команды принимают *аргументы*. Аргументы отделяются от команды символом
пробела, и между собой разделяются также пробелами.

Пример:

```
mkdir -p ~/new_dir
```

Здесь `mkdir` - это имя команды, а `-p` и `~/new_dir` - это первый и второй
аргументы. Сама команда - это аргумент с индексом `0`.

## Аргументы, содержащие символ пробела

Пробел является разделителем между аргументами. В некоторых случаях требуется,
чтобы он был значением аргумента. Есть два способа передать пробел в аргумент:
 * экранировать его с помощью символа `\`;
 * заключить весь аргумент в кавычки.

**Пример:**

```
mkdir ~/Program\ Files
mkdir ~/"Program Files (x86)"
```

Обратите внимание, что во втором случае первые два символа аргумента `~/`
**не заключены** в кавычки.

**Вопрос:** Почему не будет работать команда `mkdir "~/Program Files (x86)"`?

<!-- Правильный ответ:
Если ~ находится в кавычках, то этот символ трактуется именно как символ, а не
раскрывается в имя домашнего каталога.
-->

## Перенаправление вывода команд в файл

Команда `echo` выводит в *стандартный поток вывода* некоторый
произвольный текст. Пример ее использования:

```
echo Hello, World!
```

Обычно стандартный поток вывода отображается в терминале, но его содержимое
может быть *перенаправлено* в другой файл или другой команде.

Этот способ может использоваться для создания текстовых файлов, не используя
текстовые редакторы:

```
echo Hello, World! >hello.txt
```

Здесь будет создан текстовый файл `hello.txt`, который содержит текст,
созданный командой `echo`. При этом, на экране текст не отобразится

Оператор `>` очищает содержимое существующего файла, либо создает новый файл.

Если нужно сохранить предыдущее содержимое, то используется оператор `>>`:

```
echo Hello >hello.txt
echo World! >>hello.txt
```

## Поток вывода и поток ошибок

На экран терминала отображается содержимое двух текстовых потоков:
*потока вывода* и *потока ошибок*. В некоторых терминалах поток ошибок
выделяется красным цветом.

Операторы `>` и `>>` по умолчанию подразумевают вывод содержимого
потока вывода.

```
> python print_stdout_stderr.py >out.txt
Text of stderr

# Файл out.txt содержит текст "Text of stdout"
```

Содержимое print_stdout_stderr.py из примера выше:

```
import sys
sys.stdout.write("Text of stdout\n")
sys.stderr.write("Text of stderr\n")
```

Потоку вывода соответствует *файловый дескриптор* `1`, а потоку ошибок - `2`.
Запись `КОМАНДА >ФАЙЛ` эквивалентна записи `КОМАНДА 1>ФАЙЛ`.

Для того, чтобы перенаправить поток ошибок в файл, нужно явно указать его
файловый дескриптор:

```
python print_stdout_stderr.py 1>out.txt 2>err.txt
```

Перенаправлять потоки можно не только в физически существующие файлы, но и
в другие потоки:

```
python print_stdout_stderr.py 2>&1  # вывести оба потока в поток вывода

python print_stdout_stderr.py >combined_out.txt 2>&1
                    # вывести все содержимое в файл combined_out.txt
```


## Поток ввода

Некоторые программы ожидают ввод данных с клавиатуры. В UNIX-подобных
системах такие программы читают данные из *потока ввода*. Любой команде
можно указать произвольный файл в качестве потока ввода, - содержимое этого
файла будет использовано в качестве ввода с клавиатуры.

Для перенаправления потока ввода используется оператор `<`.

**Пример:**

```
# Программа enumerate_lines.py читает текст из потока ввода,
# и выводит исходные строки с нумерацией

python enumerate_lines.py <lorem_ipsum.txt

```

## Комбинации клавиш `Ctrl+D` и `Ctrl+C`

Реализация программы `enumerate_lines.py`, из предыдущего примера:

```
import sys
lines = sys.stdin.readlines()
for number, line in enumerate(lines):
    print("%2d: %s" % (number, line[:-1]))
```

Данная реализация читает все строки из входного потока, после чего
выполняет вывод строк с нумерацией.

В какой момент происходит завершение выполнения метода `readlines()`?

Когда программа читает данные из файла, как в примере выше, все строки
считаются прочитанными тогда, когда закончился файл.

Если чтение происходит с клавиатуры, то принудительно *закрыть
входной поток* можно с помощью комбинации клавиш `Ctrl+D`.

Многие программы, например `bash` или `python` считают закрытие
потока ввода признаком того, что пора завершать свою работу (то есть
эта операция эквивалентна команде `exit`).

Для принудидельного завершения работы программы **до того, как она выполнила
свою работу**, используется сочетание клавиш `Ctrl+C`, которое посылает
выполняемой программе сигнал о прерывании работы. Некоторые программы могут
этот сигнал перехватывать и игнорировать, либо реагировать на него каким-то
особенным образом, например `python` создает соответствующую исключительную
ситуацию.

## Команда `cat`
Выводит содержимое одного или нескольких файлов в стандартный поток вывода.

**Пример:**

```
cat file1.txt file2.txt  # на экран будет выведено содержимое сначала
                         # file1.txt, затем file2.txt
```

Эта команда часто используется для слияния нескольких файлов в один (в том
числе не только текстовых, но и бинарных):

```
cat header.txt body.txt footer.txt > document.txt
```

Если вызвать команду `cat` без аргументов, то в качестве входа испоьзуется
*стандартный поток ввода*. Таким способом можно создавать текстовые файлы,
не используя текстовый редактор:

```
cat > new_file.txt  # Будет осуществляться ввод с клавиатуры до нажатия Ctrl+D
```


## Команды `more` и `less` и перенаправление потока
Не все терминалы имеют возможность прокрутки содержимого, поэтому вывод командой
`cat` (или любой другой командой) содержимого большого текстового файла не
влезет на один экран.

Для того, чтобы организовать возможность прокрутки, предусмотрены команды
`more`, или `less`, которые принимают на вход текст из стандартного потока
ввода, и выводят его на экран постранично.

Команда `more` имеет возможность только прокрутки вперед с помощью клавиши
`ПРОБЕЛ`, команда `less` позволяет прокручивать текст как вперед, так и назад.

```
cat lorem_ipsum.txt | less
```

В данном примере программа `cat` выводит содержимое файла `lorem_ipsum.txt`
в стандартный поток вывода, а программа `less` отображает данные на экране из
стандартного потока ввода.

Оператор `|` между командами соединяет стандартный поток
вывода первой команды (`cat lorem_ipsum.txt`) со стандартным потоком
ввода второй команды (`less`), образуя *канал* передачи данных.

## Основные команды, о которых нужно помнить всегда

 * `man` - **самая нужная команда**; отображает справку по какой-либо команде
 * `cd` - перейти в другой каталог
 * `ls` - вывести содержимое каталога
 * `mkdir` - создать каталог
 * `cp` - скопировать файл или каталог
 * `mv` - переименовать файл или каталог
 * `rm` - удалить файл или каталог.

Для большинства команд предусмотрен аргумент `--help`, который отображает
короткую инструкцию по использованию команды.

### Команда `man`

`man РАЗДЕЛ ИМЯКОМАНДЫ` выводит справочную информацию по стандартным командам
UNIX, системным вызовам или функциям стандартной библиотеки Си.

Документация разбита на несколько разделов:
 * `1` - команды оболочки
 * `1p` - команды оболочки; выводится документация только на ту
 функциональность, которая соответствует стандарту POSIX
 * `2` - системные вызовы ядра операционной системы
 * `3` - функции стандартной библиотеки Си
 * `3p` - Си-функции POSIX API
 * `4` - описания модулей ядра и системных устройств
 * `5` - описания форматов конфигурационных файлов
 * `6` - описания программ для X11
 * `7` - различные руководства, не попадающие под какую-либо классификацию
 * `8` - руководства по администрированию
 * `n` - руководства Tcl.

Указывать раздел не обязательно. В этом случае будет отображен первый
найденный результат (как правило, руководство по команде). Некоторые
дистрибутивы, например openSUSE, сконфигурированы таким образом, что
команда `man` явно спрашивает номер раздела, если по запросу есть
несколько документов.

**Примеры использования**:

```
man 1p read  # отобразить справку по команде read
man 2 read   # отобразить справку по системному вызову read
man readline # отобразить справку по readline из <stdio.h>
man sudo     # отобразить справку по команде sudo
```

В последних двух случаях нужная страница присутствует только в одном
разделе справки, поэтому номер раздела не указан.


### Команда `ls`

Выводит в *стандартный поток вывода* (обычно это экран или окно терминала)
содержимое указанного каталога. Если каталог не указан в качестве аргумента,
то выводит содержимое текущего каталога.

```
ls ОПЦИИ КАТАЛОГ
```

Опции:
 * `-A` - отображать *скрытые файлы*, то есть те файлы, имена которых
 начинаются с точки
 * `-R` - рекурсивно пройти по всем подкаталогам и вывести их содержимое.


### Команда `mkdir`

Создает новый каталог. Опция `-p` указывает, что нужно создавать все
подкаталоги, которые не существуют в пути.

```
mkdir ~/new_dir  # новый каталог new_dir в домашнем каталоге
mkdir -p ~/new_dir/new_subdir1/new_subdir2
                 # новый подкаталог new_subdir2 внутри
                 # ~/new_dir/new_subdir1, которые также создаются
```

### Команды `cp` и `mv`

Команда `cp` копирует файл, а команда `mv` перемещает (равнозначно
-- переименовывает) файл.

Первый аргумент - исходный файл или каталог; второй аргумент - новое имя.
Если копируется или перемещается обычный файл, а в качестве второго аргумента
указано имя каталога, то файл будет скопирован/перемещен в указанный каталог
с сохранением своего имени.

При указании опции `-R`, можно рекурсивно копировать каталоги.

### Команда `rm`

**Внимание!** Это деструктивная команда, используйте ее с осторожностью!

Команда `rm` удаляет файл или каталог. Для удаления каталога необходима
опция `-r`.

### Еще команда: xargs

 xargs читает данные из стандартного ввода, разделяет их на части (по умолчанию пробелами или переводами строк) и передает эти части как аргументы в указанную команду.

 * зачем? Когда команда не поддерживает передачу аргументов через stdin (например, rm, mkdir).

 ```
 cat files.txt | xargs rm
 find . -name "*.txt" | xargs rm
 ```


## Подстановка вывода команд

Вывод команд может быть направлен не только в файл, но и использован как
фрагмент другой команды. Для этого команда с необходимыми аргументами
заключается в *обратные одинарные кавычки* (этот символ находится на
PC-клавиатуре на одной клавише с буквой `Ё`).

**Пример.** Команда `date` выводит текущую дату и время. В качестве аргумента
ей можно передать формат вывода, например `date +%Y%m%d-%H%M` выведет дату
и время в формате `ГГГГММДД-ЧЧММ`. Допустим, нам требуется создать временный
каталог, в имени которого присутствует дата и время. Тогда можно использовать
вывод команды `date` для формирования аргумента команды `mkdir`:

```
mkdir temp-`date +%Y%m%d-%H%M`
```

## Обработка текстов в командной строке

Задачи обработки текстов возникают очень часто, и во многих случаях для их решения совершенно не обязательно писать программы на высокоуровневых языках программирования, - можно воспользоваться стандартными утилитами среды POSIX.

### Регулярные выражения

Регулярное выражение - это текстовый шаблон, включающий в себя специальные символы-подставновки, который предназначен для поиска и замен в тексте.

Синтаксис описания регулярных выражений бывает различный, наиболее распространенный из них - это в формате языка программирования Perl, который также используется во многих других языках программирования.

Стандарт POSIX для регулярных выражений при этом является менее функциональным, и определяет два уровня языка описания: базовый (BRE) и расширенный (ERE). Расширенный синтаксис POSIX отличается от базового тем, что не требует обязательного экранирования символов скобок, а также вводит операции `?`, `+` и `|`. В дальнейшем будем использовать именно расширенный синтаксис (утилиты `sed` и `grep` требуют явного указания ключа `-E` для работы в расширенном синтаксисе).

Для тестирования регулярных выражений можно использовать веб-приложение [regex101.com](https://regex101.com), которое не поддерживает синтаксис POSIX, поэтому при написании выражений нужно не забывать о том, что не поддерживаются PCRE-специфичные конструкции, например определения классов символов через символ `\`.

Символы-подстановки, используемые в регулярных выражениях:

* `^` - начало строки;
* `.` - любой символ;
* `[   ]` - любой символ или диапазон символов, из перечисленных в квадратных скобках;
* `[^  ]` - то же самое, но с отрицанием;
* `$` - признак конца строки;
* `(   )` - группа символов или подстановок;
* `*` - повторение предыдущего символа 0 или более раз;
* `?` - повторение предыдущего символа 0 или 1 раз (только ERE);
* `+` - повторение предыдущего символа 1 или более раз  (только ERE);
* `{n}` - повторение предыдущего символа ровно `n` раз (только ERE);
* `{m, n}` - повторение предыдущего символа от `m` до `n` раз (только ERE);
* `|` - выбор одного из вариантов, между которыми встретился этот символ  (только ERE).

### Утилита grep

Утилита `grep` построчно просматривает текст из файла или стандартного потока ввода, и выполняет фильтрацию содержимого, оставляя только те строки текста, которые соответствуют шаблону.

Шаблон поиска является аргументом (заключается в кавычки, если содержит
пробельные символы или начинается с символа `-`). Часто используемые опции:
 * `-F` - выполнять поиск простого текста, а не регулярного выражения
 * `-v` - инвертировать условие поиска на противоположное
 * `-q` - ничего не выводить на экран (если требуется только код возврата)

Если найдена хотя бы одна строка, то код вовзрата равен `0`, иначе `1`.
Код возврата, отличный от `0` и `1` означает ошибку.


Пример. Содержимое исходного файла `test.txt`:

```
мама мыла раму
папа кушал сидр
акос любят все
мы все умрем
younameit чемпион younameit лучше всех
```

```
# только одна строка, которая содержит слово "мама"
> grep мама test.txt
мама мыла раму

# строки, которые содержат слова "мама" и "папа"
> grep .а.а test.txt
мама мыла раму
папа кушал сидр

# все строки, которые начинаются со слова из четырех букв
> grep -E '^.{4} ' test.txt
мама мыла раму
папа кушал сидр
акос любят все
```

В последнем примере обратите внимание на следующие особенности:

* необходима опция `-E`, поскольку используется конструкция `{n}`, определенная в расширенном стандарте;
* регулярное выражение содержит символ пробела, поэтому заключено в кавычки.

Части регулярного выражения, которые заключены в круглые скобки, запоминают вхождение текста, и могут быть использованы в самом шаблоне. Эти вхождения нумеруются от `\1` до `\9`.

```
# найти все строки, в которых слово из алфавита [а-яА-Я]
# повторяется через одно слово
> grep -E '([а-яА-Я]+) .+ \1'
younameit чемпион younameit лучше всех
```

Вместе с утилитой `grep` часто используется утилита `cut`, которая в найденной строке выбирает определенный "столбец", считая разделителем либо символ табуляции, либо какой-то произвольно заданный символ.

```
# найдем все вторые слова в строках, которые начинаются
# со слова из четырех букв
> grep -E '^.{4} ' test.txt | cut -d ' ' -f 2
мыла
кушал
любят
```

**Еще пример использования:**

**Файл some_text.txt:**

```
Hello, World!
# Hello
# This is a comment
This is not a comment
```

**Вывести все строки, содержащие слово 'Hello':**

```
cat some_text.txt | grep -F Hello
```

**Вывести все строки, содержащие фразу 'a comment':**

```
cat some_text.txt | grep -F "a comment"
```

**Вывести все строки, начинающиеся с символа решетки:**

```
cat some_text.txt | grep ^#
  # символ ^ в регулярном выражении обозначает начало строки
```

**Вывести все строки, НЕ начинающиеся с символа решетки:**

```
cat some_text.txt | grep -v ^#
```

**Определить, есть ли в тексте строка, начинающаяся с символа решетки:**

```
cat some_text.txt | grep -q ^#
echo $?  # результат 0, если найдена хотя бы одна строка
```


### Потоковый редактор sed

Помимо поиска, второй важный класс задач со строками, - это редактирование текста. Для автоматизации используются командные текстовые редакторы, такие как `sed` или `awk`. В отличии от обычных текстовых редакторов с пользовательским интерфейсом, потоковые редакторы оперируют набором команд редактирования.

Команды `sed` разделяются символом `;` и выполняют одно из действий: вставка в начало, вставка в конец, удаление и замена текста. Общий вид команд: `[ПОЗИЦИЯ]ДЕЙСТВИЕ`, где `ПОЗИЦИЯ` - это необязательная часть команды, определяющая позицию курсора редактирвоания, `ДЕЙСТВИЕ` - однобуквенная команда с возможными аргументами.

Основные команды редактирования:

* `d` удаление;
* `a` добавление текста после курсора;
* `i` добавление текста перед курсором;
* `s` замена текста по шаблону.

`ПОЗИЦИЯ` описывается одним в одном из форматов:

* `ЧИСЛО` - номер строки, которые нумеруются с 1;
* `ЧИСЛО~ШАГ` - номер строки с повторением действия через определенное количество шагов;
* `$` - последняя строка;
* `/РЕГУЛЯРКА/` - все строки, сопоставленные с шаблоном.

Набор команд является обязательным позиционным аргументом для команды `sed`. Как и для утилиты `grep`, если предполагается использование расширенного синтаксиса регулярных выражений, необходим флаг `-E`.

Если утилите `sed` не указывать имя входного файла, то подразумевается взаимодействие со стандартными потоками ввода и вывода. Если указываются файлы (их может быть несколько), то прозводится чтение из указанных файлов, причем по умолчанию используется сквозная нумерация строк по всем файлам. Для того, чтобы каждый файл обрабатывался по-отдельности, необходима опция `-s`.

Опция `-i`, также как и для `clang-format`, подразумевает сохранение изменений в исходный файл, а не вывод результата на стандартный поток вывода. Используйте эту опцию с осторожностью.

#### Примеры

```
# удалить первую и последнюю строки из файла
> sed '1d; $d' test.txt
папа кушал сидр
акос любят все
мы все умрем
```

```
# удалить все нечетные строки из файла
> sed '1~2d' test.txt
папа кушал сидр
мы все умрем
```

```
# вставить строку #!/bin/cat в начало файла
> sed '1i#!/bin/cat' test.txt
#!/bin/cat
мама мыла раму
папа кушал сидр
акос любят все
мы все умрем
younameit чемпион younameit лучше всех
```

```
# вставить пустую строку после первой строки
> sed '1a\ ' test.txt
мама мыла раму

папа кушал сидр
акос любят все
мы все умрем
younameit чемпион younameit лучше всех
```

```
# заменить слова "мама" и "папа" на "родитель"
> sed -E 's/(мама|папа) /родитель /' test.txt
родитель мыла раму
родитель кушал сидр
акос любят все
мы все умрем
younameit чемпион younameit лучше всех
```

```
# удалить все комментарии из Python-файлов текущего каталога
# (без контроля синтаксиса, в том числе из строковых констант)
> sed -i '/ *#/d' *.py
```

```
# поменять местами два первых слова в каждой строке
> sed -E 's/([а-я]+) ([а-я]+) (.*)/\2 \1 \3/' test.txt
мыла мама раму
кушал папа сидр
любят акос все
все мы умрем
чемпион younameit younameit лучше всех

# то же самое, то только для строк, начинающихся с буквы "м"
> sed -E '/^[м].*/s/([а-я]+) ([а-я]+) (.*)/\2 \1 \3/' test.txt
мыла мама раму
папа кушал сидр
акос любят все
все мы умрем
younameit чемпион younameit лучше всех
```

# Scripts

## Командные интерпретаторы

Командная строка в UNIX-подобных системах выполняет текстовые команды, и этот текст может быть записан в виде построчной программы, пригодной к выполнению из файла.

Скрипт командной строки обычно начинается со строчки вида:

```
#!/usr/bin/env bash
```

Данная строка синтаксически является комментарием во многих языках программирования, но имеет специальное назначение в UNIX-подобных системах. Исполняемые файлы, которые начинаются с символов `#!` подразумевают запуск программы-интерпретатора, указанной после `#!`, которой передается в качестве аргумента передается имя файла скрипта.

В программы-интерпретатора должен быть указан ее полный путь. Расположение некоторых интерпретаторов, например `/bin/sh`, является стандартизированным для всех UNIX-подобных систем, для других, например bash, этот путь может быть как `/bin/bash`, так и `/usr/bin/bash`  или `/usr/local/bin/bash`, - гарантировать путь однозначно нельзя. Для поиска интерпретатора в переменной окружения `PATH` используется утилита `/usr/bin/env`, которая устанавливает переменные окружения, включая `PATH`, и запускает программу, переданную ей в качестве аргумента.

## Язык программирования SH

В разных Linux-системах и других UNIX-подобных системах используются различные интерпретаторы командной строки, общим предком которых является классический интерпретатор `/bin/sh`. При этом, сам интерпретатор `/bin/sh` является символической ссылкой на используемый в дистрибутиве интерпретатор по умолчанию (за исключением MacOS, где `/bin/sh` - это `bash` старой версии, в то время как в системе используется `zsh`).

Можно считать, что программа, ориентированная на `/bin/sh` может быть запущена на любой UNIX-подобной системе, но при написании таких скриптов необходимо ориентироваться на общее подмножество функциональности различных интерпретаторов, которое регламентировано стандартом POSIX. В дальнейшем мы будем использовать интерпретатор `bash`, который присутствует во всех популярных дистрибутивах Linux, и обладает широкой фунциональностью.

Каждая команда shell-скрипта может располагаться на отдельной строке, либо заканчиваться символом точки с запятой, если необходимо записать в одну строку несколько команд.

Команды скриптов, в большинстве случаев, - это внешние программы, которые располагаются в одном из каталогов, перечисленных в переменной окружения `PATH`, но некоторые команды не могут быть реализованы как отдельные программы, поскольку изменяют текущее окружение, что не может быть сделано внешней программмой. Примерами таких команд являются:

* `cd` - изменение текущего каталога;
* `export` - делают переменную доступной дочерним процессам;
* `read` - читает текст из файла или стандартного потока ввода, и записывает результат в переменную;
* `ulimit` - устанавливает ограничения ресурсов на текущий сеанс;
* `exit` - завершает работу командного интерпретатора.

Кроме того, поскольку запуск внешних программ является ресурсозатратной операцией, в некоторых оболочках отдельные часто используемые команды реализованы как встроенные, хотя их функциональность дублируется внешними одноименными программами, например команда `echo` для интерпретаторов `bash` и `zsh`, или команда `[` для оболочки `bash` . Полный список встроенных команд для текущей оболочки можно получить командой `man builtins`.

Команды могут иметь аргументы, которые разделяютя пробелами. В случае, если аргумент должен содержать пробел, или какой-либо другой символ, имеющий специальное назначение, такой аргумент нужно заключать в кавычки. Также зарезервированные символы можно экранировать с помощью символа `\`. Список зарезервированных символов, помимо пробельных, которые нужно экранировать, или заключать в кавычки:

```
| & ; < > ( ) $ ` \ " ' * ? [ # ~ = %
```

Экранирование символа переноса строки выполняется специальным образом, что обусловлено необходимостью читабельности кода скрипта: `$'\n'`.

## Синтаксис
Командная оболочка `bash` -- это не просто строка для ввода команд, а
полноценный интерпретатор командного shell-языка.

Последовательность команд, которая выполняется в командной строке, может
быть сохранена в текстовом файле для повторного выполнения.

**Пример.** Содержимое файла `myscript.sh`:

```
mkdir ~/new_dir
touch ~/new_dir/new_file.txt
```

Выполнение этой *последовательности команд* осуществляется командой:

```
bash myscript.sh
```

Если в начало файла `myscript.sh` добавить строку (которая с точки зрения
синтаксиса является комментарием) `#!/bin/sh`, и сделать этот файл выполняемым,
то запускается он еще проще:

```
./myscript.sh
```

**Замечание 1.** Суффикс имени `.sh` не обязателен и часто опускается.

**Замечание 2.** Обратите внимание, что первая строка - это `#!/bin/sh`, а
не `#!/bin/bash`. В большинстве дистрибутивов Linux, файл `/bin/sh` является
ссылкой на `/bin/bash`, но в некоторых UNIX-системах (например FreeBSD)
интерпретатор `bash` может быть не установлен по умолчанию, а в качестве
командного интерпретатора использоваться какой-либо другой, sh-совместимый.

### Операторы
 * **`;` (точка с запятой)** -- является разделителем между последовательно
 выполняемыми командами. Этот оператор эквивалентен переносу строки
 * **`&` (амперсанд, `Shift+7`)** -- ставится после команды (и ее аргументов);
 этот оператор означает, что команда будет выполнена в фоновом режиме, а
 интерпретатор продолжает свою работу, не дожидаясь завершения работы команды
 * **`&&` и `||`** -- аналогичны операторам в языке Си. Вызов каждой команды
 возвращает целое число -- код завершения. Логическому значению "истина"
 соотвтетствует код, равный `0`; все остальные коды завершения эквивалентны
 логическому значению "ложь"
 * **`>`, `>>` и `<`** -- операторы перенаправления потока вывода (`>`, `>>`)
 и ввода (`<`) в произвольный файл или из произвольного файла; оператор вывода
 в файл `>` отличается от оператора вывода `>>` тем, что предварительно
 очищает содержимое файла
 * **`|`** -- оператор перенаправления потока вывода из одной команды в
 поток ввода другой команды; ставится между командами.


### Переменные

#### Объявление переменных

Значения переменных объявляются присваиванием:

```
ИМЯ=ЗНАЧЕНИЕ
```

Обратите внимание, что вокруг символа `=` не допускаются пробелы!

Доступ к значениям переменных осуществляется конструкцией `$ИМЯ`.
Переменные обычно именуются заглавными буквами; при использовании в имени
символа подчеркивания необходимо для доступа использовать синтаксис
`${ИМЯ_С_ПОДЧЕРКИВАНИЕМ}` (фигурные скобки вокруг имени).


#### Экспорт значений переменных запускаемым процессам

Переменные доступны только в том сеансе командной строки, в котором они
объявлены (либо до конца выполняемого файла). Для того, чтобы значения
переменных были доступны дочерним запускаемым процессам, их необходимо
*экспортировать* с помощью оператора `export`:

```
export ИМЯ=ЗНАЧЕНИЕ
```

или

```
ИМЯ=ЗНАЧЕНИЕ
export ИМЯ
```

#### Специальные имена переменных

 * `$0` - имя команды текущего процесса
 * `$1`, `$2`, `$3` и т. д. - значения аргументов, переданных shell-скрипту
 * `$*` - список, состоящий из всех аргументов, передеанных shell-скрипту
 * `$#` - количество аргументов
 * `$?` - код возврата предыдущей выполненной команды

### Ключевые слова и конструкции shell-языка

#### Комментарии

Любой текст после `#` (решетка, `Shift+3`) до конца строки является
комментарием, который игнорируется интерпретатором.

#### Проверка условия

**Синтаксис:**

```
if ВЫРАЖЕНИЕ 1
then
    НАБОР КОМАНД 1
elif ВЫРАЖЕНИЕ 2
    НАБОР КОМАНД 2
else
    НАБОР КОМАНД 3
fi
```

Обратите внимание на переносы строк (они могут быть заменены на оператор `;`).

Количество пробелов, в отличии от Python, не имеет никакого значения.

**Пример использования:**

```
#!/bin/sh

if mkdir some_dir/new_subdir
then
    echo "Subdirectory created"
else
    echo "Can't create"
fi
```


#### Выбор варианта

**Синтаксис:**

```
case ПЕРЕМЕННАЯ in
    ВАРИАНТ1|ВАРИАНТ2|ВАРИАНТ3)
       НАБОР КОММАНД 1
       ;;
    ВАРИАНТ4)
       НАБОР КОММАНД 2
       ;;
    *)
       НАБОР КОММАНД 3
       ;;
esac
```

Варианты выбора ограниичиваются закрывающей круглой скобкой; их может быть
несколько, в этом случае они разделяются вертикальной чертой.

Последовательность команд отделяется от следующего выбора двумя символами
точки с запятой `;;`.

**Пример использования:**

```
#!/bin/sh

case $1 in
    --help|-h)
    echo "Usage: $0 --help | --flag1 | --flag2"
    ;;
    --flag1|-f1)
    echo "Flag 1 set"
    ;;
    --flag2|-f2)
    echo "Flag 2 set"
    ;;
    *)
    echo "Unknown argument"
    ;;
esac

```


#### Цикл `while`

**Синтаксис:**

```
while УСЛОВИЕ
do
    НАБОР КОММАНД
done
```

**Пример использования:**

```
#!/bin/sh

echo "Press Ctrl+C to exit or type something"
while read USER_INPUT_LINE
do
    echo "Yout typed: ${USER_INPUT_LINE}"
done

```


#### Цикл `for`

**Синтаксис:**

```
for ИМЯ in СПИСОК
do
    НАБОР КОММАНД
done
```

**Пример использования:**

```
#!/bin/sh

echo "Program arguments are:"

for ARGUMENT in $*
do
    echo " ..... $ARGUMENT"
done

```

### Выполнение команд и получение их результата

Если необходимо сохранить вывод команды в переменную, то используется один из двух способов:

* \`обратные одинарные кавычки\`, между которыми заключена команда и ее аргументы;
* заключение к конструкцию `$()`.

Если вывод команды содержит в конце символы перевода строк, то они удаляются.

Пример:

```
os_name=`uname -s`
arch_name=$(uname -m)
echo "OS is $os_name running on $arch_name"
# OS is Linux running on x86_64
```

Если необходимо получить код возврата команды, а не результат ее вывода, то можно использовать переменную `$?` сразу после ее выполнения.



#### Объявление и вызов функций

Функции - это команды, которые доступны только из текущего скрипта, которым можно передавать аргументы, и они могут возвращать текст с помощью записи на "стандартный поток вывода".

Интерпретаторы `bash` и `zsh` поддерживают три вида синтаксиса объявлений:

```
# 1. Только имя и скобки
very_important_function() {
   # реализация функции
}

# 2. Полный синтаксис
function very_important_function() {
   # реализация функции
}

# 3. Без скобок
function very_important_function {
   # реализация функции
}

# вызов функции с двумя аргументами, и сохранением результата
value=$(very_important_function hello world)

# вывзов функции без сохранения возвращаемого результата
very_important_function hello world
```

Если необходимо обеспечить совместимость с произвольным интерпретатором POSIX  `sh`, то можно использовать только первый вариант объявления.

Аргументы в функцию передаются точно так же, как и в команду, и доступны через специальные переменные.

Все переменные, объявляенные внутри функции, становятся доступными глобально после ее завершения. Если переменные нужно только локально, то в `bash` и `zsh` перед объявлением переменной можно использовать ключевое слово `local`.

Функции можно импортировать из другого файла, используя синтаксис `. имя_файла`.

### Перенаправление вывода

Для передачи данных от одной функции/команды к другой, не обязательно сохранять результаты в переменную, можно передавать из через механизм перенаправления, используя оператор `|`.

```
function f() {
   # вывод kek и списка аргументов
   echo "kek $*"
}

function g() {
   # замена e на E
   sed 's/e/E/g'
}

function h() {
   # замена d на первый аргумент функции
   echo $0
   sed "s/d/$1/g"
}

f first second third | g | h Meaow
# kEk first sEconMeaow thirMeaow

# команда wc -c подсчитвает количество байт
f | wc -c
# 5

```

### Условное выполнение последовательности команд

Результатом работы команды, помимо вывода, является целочисленный код возврата, причем целое число должно быть в диапазоне от 0 до 127. Значение 0 означает успешное завершение команды, остальные значения, - признак "ошибки" или ложного значения. Код завершения предыдущей выполненной команды хранится в переменной `$?`. При объявлении функций код возврата определяется кодом возврата последней выполненной внутри функции команды, либо задается с помощью оператора `return`.

Команды можно объединять в последовательности, которые выполняются в зависимости от результата выполнения предыдущей команды:

* `cmd1 && cmd2` - `cmd2` будет выполнена, если `cmd1` выполнена успешно, а итоговый результат - это код возврата `cmd2`;
* `cmd1 || cmd2` - `cmd2` будет выполнена, если не удалось успешно выполнить `cmd1`, результат - либо значение 0, либо код возврата `cmd2`.

Выполнение цепочки команд можно заключать в круглые скобки для указания приоритетов логических операций.

```
function f() {
    echo "I'm function f"
    return 0
}

function g() {
    echo "I'm function g"
    return 5
}

function h() {
    echo "I'm function h"
    return 0
}

f && g && h    # вывод только от f и g, но не h
echo "---"
f && (g || h)  # вывод от f, g и h
```

Предусмотрены две программы, которые не делают абсолютно ничего, а только возвращают код 0 или 1: это команда `true`, и команда `false`. Они предназначены для использования внутри таких "логических выражений", например, если нужно подавить код ошибки для необязательной операции:

```
rm -f файл_который_не_существует || true  # всегда будет успешный код возврата
```



### Команда `[`

`[` - это *программа*, которая располагается в `/usr/bin`, предназначенная
для формирования логических выражений в виде `[ ВЫРАЖЕНИЕ ]`. В завимости
от результата проверки аргументов, возвращает нулевой либо ненулевой код
возврата, предназначенный для операторов `if` или `while`.

**Внимание!** В отличии от оператора присваивания, символ `=` и другие
символы сравнения являются аргументами команды `[`, и должны
отделяться пробелом.

#### Проверка строковых значений
 * `-n СТРОКА` - истина, если длина строки ненулевая
 * `-z СТРОКА` - истина, если строка пустая
 * `СТРОКА1 = СТРОКА2` - истина, если строки равны
 * `СТРОКА1 != СТРОКА2` - истина, если строки различные

#### Проверка численных значений
 * `ЧИСЛО1 -eq ЧИСЛО2` - числовое равенство
 * `ЧИСЛО1 -ne ЧИСЛО2` - числовое равенство
 * `ЧИСЛО1 -gt ЧИСЛО2` - ЧИСЛО1 > ЧИСЛО2
 * `ЧИСЛО1 -ge ЧИСЛО2` - ЧИСЛО1 >= ЧИСЛО2
 * `ЧИСЛО1 -lt ЧИСЛО2` - ЧИСЛО1 < ЧИСЛО2
 * `ЧИСЛО1 -le ЧИСЛО2` - ЧИСЛО1 <= ЧИСЛО2

#### Часто используемые проверки аттрибутов файлов
 * `-e ИМЯФАЙЛА` - указанный путь существует
 * `-d ИМЯФАЙЛА` - указанный путь существует и является каталогом
 * `-f ИМЯФАЙЛА` - указанный путь существует и является обычным файлом


### Конструкция условия и команда [

Логические условия могут быть использованы условных конструкций, как в обычных языках программирования.

```
if true
then
   # эта часть всегда будет выполняться
fi

if false
then
   # это не будет выполняться никогда
fi
```

Аргументом команды `if` может быть любая команда. Истинным условием считается нулевой код возврата, а ложным - ненулевой. Для выполнения различных логических операций служит конструкция `[ .... ]`,  которая реализована, в общем случае, с помощью отдельной команды `[`.

* `$x -eq $y` - истина, если значения `$x` и `$y` равны;
* `$x -nq $y` - истина, если значения `$x` и `$y` не равны;
* `$x -gt $y` - истина, если значение `$x` > `$y`;
* `$x -lt $y` - истина, если значение `$x` < `$y`;
* `$x -ge $y` - истина, если значение `$x` >= `$y`;
* `$x -le $y` - истина, если значение `$x` <= `$y`;
* `-n $str` - истина, если строка `$str` не пустая;
* `-z $str` - истина, если строка `$str` пустая;
* `$str1 = $str2` - истина, если строки `$str1` и `$str2` равны;
* `-e $pathname` - истина, если существует путь `$pathname`;
* `-f $filename` - истина, если существует обычный файл `$filename`;
* `-d $dirname` - истина, если существует каталог `$dirname`;
* `-x $filename` - истина, если существует обычный файл `$filename`, и он является выполняемым.

Внутри конструкции `[ ... ]` можно использовать круглые скобки для указания приоритетов, и оператор отрицания `!`.

Важно особенностью этой конструкции является то, что между символами `[`, `]` и разными операторами внутри конструкции обязавтельно должны быть пробельные символы, поскольку это вызов команды с аргументами.

### Циклы

Простейшим циклом является цикл `while`, аргумент которого точно такой же, как у конструкции `if`.

```
while true
do
   # не только простейшая, но и самая
   # опасная конструкция, поскольку цикл
   # может никогда не завершиться
done
```

Конструкция `for` предназначена для итерации по элементам списка.

```
# 1. Итерация по элементам простого списка
for item in i love akos
do
   echo "$item"
done

# 2. Итерация по элемента генерируемого по маске списка файлов
for filename in *.txt
do
   echo "$filename might be plain text"
done
```

Интерпретаторы `bash` и `zsh` имеют еще одну, нестандартную для POSIX `sh`, конструкцию циклов, которая синтаксически близка к Си-подобным языкам.

```
# только bash/zsh

for (( i=0; i<10; i++ ))
do
   echo "$i"
done
```

### Internal Field Separator

Элементы списка разделяются символом пробел в самом скрипте, если они перечислены после ключевого слова `in`, но могут также быть прочитаны из файла, либо получены из произвольной строки.

```
for item in $(echo "i love    akos")
do
  echo "$item"
done

# i
# love
# akos
```

В этом случае разделителями считаются подряд идущие последовательности пробельных символов: пробел, табуляция и символ перевода строки. Часто бывает необходимо переопределить символ разделителя, например для обработки текстовых файлов определенного формата. Для этого предназначена специальная переменная интерпретатора `IFS` (аббривеатура от Internal Field Separator).

```
IFS=💞
for item in $(echo "i💞love💞💞💞akos")
do
    echo "$item"
done

# i
# love
#
#
# akos
```

После переопределения символа в переменной `IFS` , разделители не группируются. В качестве разделителя можно использовать только односимвольную строку, причем интерпретаторы `bash` и `zsh` корректно обрабатывают многобайтные символы Юникода, но это не гарантируется для других интерпретаторов.

Чтение из файла можно организовать либо через команду `cat`, либо используя встроенную функцию `read` (обычно используется внутри цикла `while`), которая читает очередную лексему, ограниченную разделителем из `IFS`, и возвращает код 0, в случае успешного чтения.

### Арифметика

Командный интерпретатор `sh` позволяет вычислять произвольные арифметические выражения, но с принципиальным ограничением: допускается только знаковая целочисленная арифметика. Синтаксически операции эквивалентны таковым в других языках программирования, а сами выражения заключаются в конструкцию `$(( ... ))`. В отличии от команды `[`, круглые скобки не являются внешней командой, поэтому пробельные символы не обязательны.

```
a=5
b=3
c=$(($a+$b))
d=$(($a/$b))

echo "a = $a, b = $b, c = $c, d = $d"
# a = 5, b = 3, c = 8, d = 1
```

Для вычислений с вещественнозначными значениями можно использовать простой консольный калькулятор `bc` (Basic Calculator). Эта программа выполняет вычисление арифметических выражений, позволяет использовать функции логарифма, экспоненты и тригонометрические функции.

```
echo '(1+3)*2' | bc
# 8

# по умолчанию используется целочисленная арифметика,
# флаг -l подключает дополнительную функциональность
echo '(1+3)/2.5' | bc -l
# 1.60000000000000000000
```

### Массивы

Массивы являются нестандартным расширением  `sh`, реализованным (по-разному) в командных интерпретаторах `bash` и `zsh`.

Переменные массива объявляются как список, разделенный пробельными символами, заключенный в круглые скобки. Пустой массив обявляется как `()`.

Элементы массива можно индексировать целыми числами с 0 (для `bash`) или с 1 (для `zsh`). Индексы указываются в квадратных скобках, поэтому для исключения неоднозначности операторов, при использовании значения из массива, обязательно заключать переменную с индексом в фигурные скобки.

Адресация массива целиком (например, для вывода), а не его отдельного элемента осуществляется с указанием индекса `[@]`. Размер массива определяется как `${#массив[@]}`.

```
# пример для bash - индексация с 0

array=(1 2 3 4 5 6)
array_size=${#array[@]}

for (( i=0; i<$array_size; i++ ))
do
    # удвоенное значение
    array[$i]=$(( ${array[$i]} * 2 ))
done

echo "${array[@]}"
```


### Команды `read` и `printf`

Для ввода-вывода данных (в основном - при написании скриптов) используются
команды `read` и `printf`

Команда `read` читает одну строку (до символа `\n`)из потока ввода,
и сохраняет ее значение в указанной переменной:

```
read SOME_VAR  # пользователь вводит строку
echo ${SOME_VAR}
```

Если поток данных завершился до ввода строки, то возвращается не нулевой
код возврата. Это можно использовать для огранизации цикла `while`.

Для вывода значений переменных, помимо команды `echo`, можно использовать
форматный вывод, аналогично Си:

```
A=123
B=3.14159
C=Text
D="Hello, World"  # D - содержит СПИСОК из двух слов, а не строку!
printf "%d -- %f\n%s\n%s\n" $A $B $C "$D"  # обратите внимание на кавычки
```
### set -e

В Bash команда set -e (или set -o errexit) используется для того, чтобы скрипт автоматически завершался с ошибкой, если любая из выполненных команд возвращает ненулевой код завершения (то есть завершается с ошибкой). Это помогает сделать скрипты более надежными и предотвращает продолжение выполнения скрипта после возникновения ошибки, что может привести к нежелательным последствиям.








