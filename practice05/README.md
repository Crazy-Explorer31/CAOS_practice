* 01-small-details

    * endian

    ⚠️ Warning! Пример для 32-битного ассемблера, но смысл от этого не меняется.

    Каждый байт памяти имеет свой адрес. Когда мы говорим, что что-то находится по какому-то адресу, мы имеем в виду, что первый байт этого чего-то лежит по адресу.

    Рассмотрим число `10111010 11011101 11110000 00001101` или в 16-ричном представлении `0xBADDF00D`. Так как число имеет размер 32 бита или 4 байта, то нам нужно 4 ячейки памяти, чтобы его сохранить.

    У нас есть 2 способа созранить число: более значимые байты (не биты) размещать слева направо или наоброт справа налево. Рассмотрим на примере.

    | Endianness \ адрес памяти | 11a0 | 11a1 | 11a2 | 11a3 |
    |---------------------------|------|------|------|------|
    |     Little Endian         |  0D  |  F0  |  DD  |  BA  |
    |     Big Endian            |  BA  |  DD  |  F0  |  0D  |

    Little Endian - порядок, в котором менее значимые байты находятся в начале.

    Big Endian - порядок, в котором более значимые байты находятся в начале.

    Чаще всего используется Little Endian.

    | ⚠️ Warning                                                                                                               |
    | ------------------------------------------------------------------------------------------------------------------------ |
    | В little endian идут в обратном порядке именно байты. То есть число лежит в памяти как `0D F0 DD BA`, а не `D0 0F DD AB` |


    * Disasm программы на C (что делает внутри https://gcc.godbolt.org/?)
        * `gcc -S -masm=intel -fverbose=-asm -O0 main.c`-o main.S

    * В GDB можно передавать команды из файла

 * 02-local-vars

    * Пролог/эпилог

    Обычно функции принято оформлять специальным образом. В начало добавлять пролог:
    ```
    push    rbp
    mov     rbp, rsp
    ```
    стек
    ```
    0000 [old_rbp, return_address, param1] ffff
          ^rbp
          ^rsp
    достать param1:  mov [rbp + 16], rax
    ```

    В конце функции делают эпилог:
    ```
    mov     rsp, rbp
    pop     rbp
    ```

    *  Выравнивание стека
    Перед `call` стек должен быть выровнен по 16 байтам. Это значит, что адрес вершины стека должен делиться на 16.

    В GDB адрес вершины стека можно проверить так:

    ```
    p $rsp
    ```

    он делится на 16, если последняя цифра 0. Или же можно проверить вот так:
    ```
    p (uint64_t)$rsp%16
    ```
    остаток должен быть 0.

        * NB1: *должен быть выровнен до call*: call заносит на стек RA (rsp += 8) => после call опять не выровнен
        * NB2: пролог push rbp (rsp += 8) => опять выровнен

        * call из функции ломается, если не было push rbp (который выровнял на 16)

* Посмотреть стек
```
p/x $rsp
addr
p *((long long int*)addr)@len
```

```
p *((long long int*)$rsp)@len
```
