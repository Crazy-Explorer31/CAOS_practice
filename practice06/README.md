* 01-small-details
    * 01-exit-code
        * соглашение в ОС: код возврата = содержание регистра rax после завершения программы
        * код возврата != 0 => ошибка
        * bash:код возврата предыдущей команды
            ```
            ./01-exit-code
            echo $?
            ```
            ```
            # && means execute the statement which follows only if the preceding statement executed successfully (returned exit code zero).
            # || means execute the statement which follows only if the preceding statement failed (returned a non-zero exit code).
            ./01-exit-code || echo "Failed"
            ```
    * 02-pure-asm: call -- вызов функции, syscall --- вызов функции операционной системы

    * 03-asm-cpp-func

        Так как в `C++`, в отличие от `C`, разрешены перегруженные функции (различающиеся только аргументами), их имена изменяются с помощью _name mangling_ — процесса преобразования имен функций. Подробнее можно прочитать здесь: [https://www.emmtrix.com/wiki/Demystifying_C%2B%2B_-_Name_Mangling](https://www.emmtrix.com/wiki/Demystifying_C%2B%2B_-_Name_Mangling).

        В нашем случае, функция `sum(int a, int b)` в скомпилированном виде будет иметь имя `_Z3sumii`. Линковщик для `C++`-файла попытается найти именно эту функцию, которой в `.S` файле нет, из-за чего произойдет ошибка линковки.

        Использование `extern "C"` заставляет компилятор генерировать имена функций по правилам `C` (где имена должны быть уникальными, даже если аргументы разные). В результате линковщик будет искать функцию `multiply_add`, которая уже присутствует в `.S` файле, и линковка пройдет успешно.
* 03-stdio


Мануалы по командам:

printf:  `man 3 printf`

scanf:   `man 3 scanf`

## Список модификаторов

```
%d — целое число типа int в десятичной системе счисления;
%u — целое число типа unsigned int;
%x — целое число типа int в шестнадцатеричной системе счисления;
%o — целое число типа int в восьмеричной системе счисления;
%hd — целое число типа short в десятичной системе счисления;
%hu — целое число типа unsigned short;
%hx — целое число типа short в шестнадцатеричной системе счисления;
%ld — целое число типа long int в десятичной системе счисления;
%lu — целое число типа unsigned long int;
%lx — целое число типа long int в шестнадцатеричной системе счисления;
%llx — целое число типа long long в шестнадцатеричной системе счисления;
%f — вещественный формат (числа с плавающей точкой типа float);
%lf — вещественный формат двойной точности (числа с плавающей точкой типа double);
%e — вещественный формат в экспоненциальной форме (числа с плавающей точкой типа float в экспоненциальной форме);
%c — символьный формат;
%s — строковый формат.
```

## Специальные символы

```
  \r - carriage return - возвращение каретки в начало строки (использовалось в progress bar)
  \n - перенос строки
  \t - таб
  %20d - напечатать int в окне размером 20. Выравнять по правой стороне.
  %-20d - напечатать int в окне размером 20. Выравнять по левой стороне.
  %0.2f - вывести float число с 2 знаками после запятой
```

## Buffer

printf - line-buffered. Это означает, что он не выводит сразу же, когда мы его вызвали, а копит все в буфере и старается выводить как можно реже, но большим объемом.

Это нужно для того, чтобы как можно реже обращаться к операционной системе. В примере [buf_speed.c](buf_speed.c) мы видим, что буферизованный вывод сработал в 3 раза быстрее.

Сбрасывает буфер (то есть выводит) printf при наступлении специальных условий:

1. Встретился символ переноса строки (\n) - так как printf построчно буферизует
2. Сделали `fflush` - сказали явно сбросить буфер
3. Буфер переполнился
4. Программа завершилась

# Переполнение буфера scanf

[test_overflow.c](test_overflow.c)

```c
#include <stdio.h>
#include <string.h>

int main() {

    char input[9];
    char password[9] = "password";

    // Чтобы избежать ошибки, нужно всегда указывать в scanf размер ввода:
    // scanf("%8s", input);
    scanf("%s", input);

    if (strcmp(input, password) == 0) {
        printf("Access granted\n");
    } else {
        printf("Access denied\n");
    }

}
```

scanf будет считывать пока не закончится ввод.

Если явно ему не сказать считать 8 символов: `scanf("%8s")`, то он будет считывать даже когда input переполнится.

Так как input и password лежат на стеке поряд, то когда input переполнится scanf начнет записывать уже в password.

Поэтому если мы подберем хитро input, например: `aaaaaaaa\0aaaaaaaa\0`, то мы не зная настоящего пароля добьемся вывода `Access granted`.

Проверить: `echo -e 'aaaaaaaa\0aaaaaaaa\0' | ./a.out`

В input поместится `aaaaaaaa\0` - валидная null-terminated строка, дальше input переполнится и password перезатрется, туда поместится следующая часть ввода `aaaaaaaa\0` - та же строка, что и в input.

Дальше strcmp побайтово сравнит строки и вернет 0 (признак равенства строк)
